# Лабораторная работа 7  
**Тема:** Преобразование и анализ кода с использованием Clang и LLVM.  
- Цель: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.
---



1. Работа выполнялась в среде Ubuntu 22.04. Установлены следующие 
инструменты:
 
● clang — компилятор языка C/C++; 

● llvm — инструменты анализа и оптимизации кода; 

● opt — инструмент для работы с LLVM IR и применения 
оптимизаций; 

● Graphviz — инструмент для визуализации кода. 

Команда установки: sudo apt install clang llvm

![image](https://github.com/user-attachments/assets/d59abf23-1eb9-4d65-b9fa-64e8474e5aad)

---
2. Исходный код
   
Программа на языке C: 

#include <stdio.h> 

int square(int x) { 

      return x * x; 

} 

int main() { 

int a = 5; 

int b = square(a); 

printf("%d\n", b); 

return 0; 

} 

Сохранена в файл main.c.
![image](https://github.com/user-attachments/assets/95ce485b-7981-40e7-ab27-1532defdfffc)
---
3. Получение AST
   
Команда: clang -Xclang -ast-dump -fsyntax-only main.c
![image](https://github.com/user-attachments/assets/97f2cb7b-9656-4dc0-996e-6c3dbae10e08)
Функция square принята, содержит параметр x и возвращает x * x.
---
4. Генерация LLVM IR
   
Команда: clang -S -emit-llvm main.c -o main.ll
![image](https://github.com/user-attachments/assets/e8be1098-f58b-4b2d-9308-5393fdfd75df)
![image](https://github.com/user-attachments/assets/309b853e-052c-447a-acd4-962984f59303)
---
5. Оптимизация IR
   
 Команда: clang -O0 -S -emit-llvm main.c -o main_O0.ll
 
 Стоит отметить, что в файле с IR до оптимизации:
 
 Все переменные (a, b, x.addr) размещены в памяти через alloca; 
 
 Множество операций load и store; 
 
 square вызывается как отдельная функция.
![image](https://github.com/user-attachments/assets/5922ade3-ac4f-4072-92a5-c24bf1f9e108)
![image](https://github.com/user-attachments/assets/e5573a7a-081c-4610-bd5e-18a970f2801b)
Команда: clang -O2 -S -emit-llvm main.c -o main_O2.ll

Команда -O2 – комплексная оптимизация среднего уровня. Она 

применяет более 30 различных оптимизаций: 

● -inline – встраивание небольших функций (встраивает square в 
main, если она вызывается один раз); 

● -constprop – подставит значение square(5) → 25, если функция 
встроена и всё известно на этапе компиляции; 

● -mem2reg – перевод переменных из памяти в регистры (SSA); 

● -instcombine – объединение и упрощение инструкций 
(упростит арифметику, например x * x может быть преобразовано в shl при 
x = 2^n); 

● -simplifycfg – оптимизирует структуру блоков (Упростит граф 
управления, если после inlining останутся лишние блоки); 

● -reassociate, -gvn, -sroa, -dce и другие. 

В файле с IR после оптимизации: 

Вся функция square исчезла – она была встроена (-inline) и затем 
вычислена (оптимизация -constprop); 

Никаких переменных, alloca, store, load – всё удалено (оптимизации -mem2reg, -dce); 

Остался только вызов printf(25).

![image](https://github.com/user-attachments/assets/c687c0d3-e4ea-47b0-a1e6-6516b3db83c7)
![image](https://github.com/user-attachments/assets/fa862dab-3057-407e-99cd-e819e4174fe4)

Команда: diff main_O0.ll main_O2.ll 

Сравнение двух файлов:

![image](https://github.com/user-attachments/assets/42e31cd5-bbb9-41e0-896d-656f601f0ff5)
![image](https://github.com/user-attachments/assets/227a6072-eeb2-49cb-8ba0-ccac1be5e89f)
Стоит отметить, что после оптимизации произошли следующие 
изменения: 

● Переменные типа alloca были удалены; 

● Код переведён в SSA-форму; 

● Оптимизация улучшила читаемость и упростила поток 
управления.
---
6. Граф потока управления программы 

Команда для генерации оптимизированного LLVM IR: clang -O2 -S -emit-llvm main.c -o main.ll 

Команда для генерации .dot-файлов CFG для функций: opt -dot-cfg -disable-output main.ll

![image](https://github.com/user-attachments/assets/8849e638-fef8-4b78-852a-a1c226cd1bc0)
![image](https://github.com/user-attachments/assets/6662cfaa-e564-485a-912c-0e5fa89f06c4)
Эта команда создаст DOT-файлы: .main.dot – для функции main; 

.square.dot – для square, если она не была удалена оптимизацией. 

Команда для установки библиотеки Graphviz: sudo apt install graphviz 

Команды для преобразования файлов с расширением .dot в .png с 
помощью Graphviz:  

dot -Tpng .main.dot -o cfg_main.png 

dot -Tpng .square.dot -o cfg_square.png 
Команды для просмотра файлов с CGF: 
xdg-open cfg_main.png

![image](https://github.com/user-attachments/assets/19a9533d-1802-4d5c-b839-0d9815064c57)
xdg-open cfg_square.png

![image](https://github.com/user-attachments/assets/d6dade55-8ea4-4a97-a312-194ae454cf98)
Стоит отметить, что в LLVM каждый граф потока управления (CFG) строится на уровне функции, поскольку структура управления всегда локальна для тела функции. Для получения полного представления о программе, нужно построить CFG для всех функций и анализировать их совокупность. Автоматическое объединение всех CFG в один граф не предусмотрено в LLVM по умолчанию.

# Выводы

● С помощью Clang можно получить полную структуру AST и 
IR, а также CGF; 

● LLVM предоставляет гибкие инструменты анализа и 
оптимизации; 

● Промежуточное представление кода удобно для написания 
компиляторных трансформаций.
---
# Контрольные вопросы
1.	Что такое Clang, и какова его роль в процессе компиляции программ?

Clang — это фронтенд-компилятор для языков C, C++ и Objective-C, реализованный на базе инфраструктуры LLVM. Его задача — взять исходный код, провести лексический и синтаксический анализ, сгенерировать абстрактное синтаксическое дерево (AST) и превратить его в промежуточное представление LLVM IR, которое затем передаётся в бэкенд LLVM для оптимизаций и генерации машинного кода.

2.	Что представляет собой LLVM и как он используется в современных компиляторах?

LLVM — это модульная инфраструктура (фреймворк) для создания компиляторов и инструментов анализа. В ней определено единое низкоуровневое промежуточное представление (LLVM IR) и набор оптимизационных пассов, которые можно легко комбинировать. Современные компиляторы (Clang, Rust, Swift и др.) используют LLVM как бэкенд для оптимизации IR и генерации объектного/машинного кода под разные архитектуры.

3.	Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

AST отражает синтаксис и семантику исходного языка — уровни вложенности выражений, операторов, объявлений.

LLVM IR — трёхадресный низкоуровневый язык с инструкциями (add, mul, br и т. д.), рассчитанный на упрощённые анализ и оптимизацию. AST ближе к исходному коду, IR — к машинному.

4.	Для чего необходимо промежуточное представление (IR) в процессе компиляции?

IR служит единой «рабочей моделью» программы, независимой от синтаксиса исходного языка и аппаратной архитектуры. На нём реализуются все анализы и оптимизации, после чего IR последовательно переводят в машинный код для конкретной платформы.

5.	Что делает инструкция alloca в LLVM IR, и зачем она используется в функциях?

alloca выделяет область в стеке текущей функции под локальную переменную. При вызове alloca i32 внутри функции LLVM резервирует память на стеке для одного 32-битного целочисленного объекта.

6.	Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?

Основные цели оптимизаций — повысить скорость выполнения, уменьшить размер итогового кода и/или сократить энергопотребление. Для этого удаляются избыточные вычисления, упрощаются выражения, объединяются похожие операции, устраняются неиспользуемые переменные и функции.

7.	Что такое SSA-форма и почему она важна при оптимизации программ?

SSA (Static Single Assignment) — это представление, в котором каждая переменная присваивается ровно один раз. Для того чтобы при конвертации несколько разных присваиваний одного имени разбивались на разные версионированные «имена», вводятся функции Φ (фай). SSA упрощает многие оптимизации (канонизация, константное распространение, устранение мёртвого кода), так как делает явными зависимости данных.

8.	Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?

CFG — ориентированный граф, где вершины — базовые блоки (последовательности инструкций без переходов), а рёбра — возможные переходы управления (условные и безусловные). На его основе удобно выполнять анализы (поиск недостижимого кода, оценка цикла, построение SSA, трассировка ошибок и т. д.).

9.	Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?

Арифметика в LLVM IR выражается инструкциями трёхадресного кода, например:

%sum   = add i32 %a, %b

%prod  = mul i32 %x, %y

%fsum  = fadd float %fa, %fb

%icmp  = icmp slt i32 %a, %b      ; сравнение

здесь add, mul, fadd, icmp — отдельные инструкции с явными типами и операндами.

10.	Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?

Функции тематически изолированы: каждую можно независимо оптимизировать (инлайнинг, удаление, векторизация). Это облегчает масштабирование на большие проекты и позволяет применять более агрессивные проходы внутри функции, не затрагивая сразу всю программу.

11.	Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?

Как правило, такая функция инлайнится (встраивается) в место вызова. После этого её тело встраивается в вызывающую функцию, а сам define-блок функции может быть удалён как «мёртвый» (неиспользуемый).

12.	Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

•	Машинно-независимость: оптимизации работают одинаково для разных языков и целевых архитектур.

•	Чёткость зависимостей: SSA/CFG выявляют все зависимости данных и управления.

•	Модульность: пассы легко комбинировать и переиспользовать.

•	Производительность: анализ и трансформации на IR выполняются быстрее, чем разбор исходного текста и глубокое понимание всех особенностей языка C.


